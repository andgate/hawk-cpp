< Test

namespace_1:
  test :: () :=
    print "Hello from namespace1"
// No longer inside namespace1


// This is an object definition
SomeData :-
// Set access 
private:
    // Struct containing data
    a :: Int := 32 // Defaults to 32
    
    // Defines a getter and setter for the field, similar to c# properties
    @ get set
    c :: String // Defaults to empty string
        // creates a public setter for c
        set c := return this.c + c
        // Uses the default, public getter for c
        
    // Function pointers can be made by wrapping the type sig in parenthesis
    f :: (String -> String -> i32)
    
    @protected // Specific access for a field
    b :: Int // Defaults to default int, which is 0
    
public:
    // Constructors are special!
    // Data can be initialized in a constructor, but only once!
    // Order of initialization is determined from constructor
    SomeData a b c :=
        this.a := a
        this.b := b
        this.c := c
        
        // Do some extra construction work
        this.y += z.size
        
    // Destructors are called when an object is deallocated
    // Destructors can be deleted
    @ disable
    ~SomeData = delete

    // Undefined functions are considered abstract
    @ abstract // Forces abstract function check
    foo a :: !Int -> ()
    
// Inheritance is done with backwards arrow
MyData <- SomeData :-
    @Override
    foo x :=
        b += x
    
    
// This is an enum definition
// The lexer will attempt to parse types as
// either objects or enums
// Notice that case of the type doesn't matter, unlike some other languages.
colors :- Red | Blue | Green
    
@ start // Declares add as an entry point. When compiled, will produce a binary that starts here.
// This is a function definition
// Function definitions can have an optional type signature
// Types can be declared constant with a bang prepended.
// Pointers can prepended to the start as well, and work just like c pointers.
add x y :: !i32 -> !i32 -> !i32 :=
  z : Int // Delcares z, defaults to 0
  z = x + y // This allows z to be set to a given rvalue.
  // If multiple statements were used, a call to return is required.
  
  z : Int := x + y // Shadows previous z with a new declaration
  return z // control-flow statements like return are employed.

